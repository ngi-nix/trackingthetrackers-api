#!/usr/bin/env python

import json
import datetime
import psycopg2
import logging
from config import *


class FileEntry():
    filename: str
    path: str
    md5: str
    sha1: str
    sha256: str                     # for us, the sha256 is the primary key
    contains_malware: bool
    contains_trackers: bool
    contains_adware: bool
    first_seen: datetime.datetime
    analyzed_at: datetime.datetime

    def __init__(self, filename: str, path: str, md5: str, sha1: str, sha256: str, contains_malware: str = None):
        self.filename = filename
        self.path = path
        self.md5 = md5
        self.sha1 = sha1
        self.sha256 = sha256
        self.contains_malware = contains_malware
        self.first_seen = datetime.datetime.now()
        self.analyzed_at = None

    def __hash__(self):
        return self.sha256

    def __eq__(self, other):
        return self.sha256 == other.sha256

    def __str__(self):
        return json.dumps({
            'filename': self.filename,
            'path': self.path,
            'md5': self.md5,
            'sha1': self.sha1,
            'sha256': self.sha256,
            'contains_malware': self.contains_malware,
            'first_seen': str(self.first_seen),
            'analyzed_at': str(self.analyzed_at)
        })


class FileEntryCache(dict):
    """
    The file Entry Cache stores all analysed entries
    """
    db_conn = None

    def __init__(self):
        try:
            self.db_conn = psycopg2.connect(dbname=config['DATABASE'],
                                         user=config['USERNAME'],
                                         password=config['PASSWORD'],
                                         host=config['DBHOST'])
            self.db_conn.set_session(autocommit=True)
        except Exception as ex:
            logging.error("could not connect to the database. Reason %s" %str(ex))
            raise

    def __del__(self):
        self.db_conn.close()

    def __contains__(self, entry: FileEntry) -> bool:
        return (self._lookup_count(entry) > 0)

    def was_analyzed(self, entry: FileEntry) -> bool:
        return entry in self

    def _lookup_count(self, entry: FileEntry) -> int:
        SQL = 'SELECT count(*) from "cache" WHERE sha256 = %s'
        try:
            cur = self.db_conn.cursor()
            cur.execute(SQL, (entry.sha256,))
            rows = cur.fetchall()
            if cur.rowcount > 0:
                return int(rows[0][0])
            else:
                return 0
        except Exception as ex:
            logging.error("Could not lookup %r. Reason: %s" %(str(entry), str(ex)))
            return 0

    def insert(self, entry: FileEntry) -> bool:
        """ inserts an entry into the BinCache """
        e = entry
        SQL = '''INSERT INTO "cache" (
                    filename, 
                    path_on_disk, 
                    md5, 
                    sha1, 
                    sha256, 
                    contains_malware, 
                    first_seen, 
                    analyzed_at
                )
            VALUES (%s, %s, %s, %s, %s, %s, now(), NULL)'''     # XXX FIXME: analyzed_at is empty
        try:
            cur = self.db_conn.cursor()
            print(cur.mogrify(SQL, (e.filename, e.path, e.md5, e.sha1, e.sha256, e.contains_malware)))
            cur.execute(SQL, (e.filename, e.path, e.md5, e.sha1, e.sha256, e.contains_malware))
            if 1 != cur.rowcount:  # did not update anything at all actually
                logging.warning("insert(): did not insert fileEntry %r" %str(e))
            else:
                logging.info("insert(): success")
                # self.db_conn.commit()     # XXX have autocommit
                return True
        except Exception as ex:
            logging.error("could not insert into DB: %r. Reason: %s" % (e, str(ex)))
            self.db_conn.rollback()
        return False

    def __items__(self) -> []:
        """ returns the DB entries. """
        SQL = '''SELECT 
              filename,path_on_disk as path, md5, sha1, sha256, contains_malware, first_seen, analyzed_at 
              FROM "cache"'''
        try:
            cur = self.db_conn.cursor()
            cur.execute(SQL)
            rows = cur.fetchall()
            return rows
        except Exception as ex:
            logging.error("Could not SELECT *. Reason: %s" % str(ex))
            return []

    def __len__(self) -> int:
        """ returns the number of DB entries. """
        SQL = 'SELECT count(*) from "cache"'
        try:
            cur = self.db_conn.cursor()
            cur.execute(SQL)
            rows = cur.fetchall()
            if cur.rowcount > 0:
                return int(rows[0][0])
            else:
                return 0
        except Exception as ex:
            logging.error("Could not SELECT count(*). Reason: %s" % str(ex))
            return 0

    def contains_malware(self, entry: FileEntry) -> bool:
        """
        Returns the result of the cache of the given entry
        @param entry: entry
        @return bool: is malware Y/N? Or None if not known
        """
        (contains_malware, _contains_trackers, _contains_adware) = self.get_cached_result(entry)
        return contains_malware

    def get_cached_result(self, entry: FileEntry) -> (bool, bool, bool):
        """
        Returns the result of the cache of the given entry
        @param entry: entry
        @return a tuple of  bools (contains_malware? Y/N, contains_trackers, contains_adware )
            or None if there was no match
        """
        SQL = 'SELECT contains_malware, contains_trackers, contains_adware from "cache" WHERE sha256 = %s'
        try:
            cur = self.db_conn.cursor()
            cur.execute(SQL, (entry.sha256,))
            rows = cur.fetchall()
            if cur.rowcount > 0:
                return bool(rows[0])
            else:
                return None
        except Exception as ex:
            logging.error("Could not lookup cached result %r. Reason: %s" %(str(entry), str(ex)))
            return None



if __name__ == "__main__":
    entry = FileEntry(filename = "foo", md5 = "42", sha1 = "42", sha256 = "42")
    print(str(entry))

    e1 = FileEntry(filename = "foo", md5 = "42", sha1 = "42", sha256 = "42")
    e2 = FileEntry(filename = "foo", md5 = "43", sha1 = "43", sha256 = "43")
    e3 = e1

    print("e1 == e2 ? %r" %(e1 == e2))
    print("e1 == e3 ? %r" %(e1 == e3))
    print("e2 == e3 ? %r" %(e2 == e3))

    print("hash(e1) = %s" % e1.__hash__())

    cache = FileEntryCache()
    cache.insert(entry)
    cache.insert(e2)
    if entry in cache:
        print("found entry %s in cache" % entry)
    entry2 = entry
    entry2.sha256 = "43"
    assert entry2 in cache
    print("did not find entry2 in cache. As expected")
    print("we have %d entries in the DB" % len(cache))

    # checking analysis cache
    print("checking if 42 was analyzed. Expecting True: %s" % (cache.was_analyzed(entry)))
    e4 = FileEntry(filename = "nonexistent", md5 = "44", sha1 = "44", sha256 = "44")
    print("checking if 44 was analyzed. Expecting False: %s" % (cache.was_analyzed(e4)))

    for item in cache.items():
        print("%s" % item)
