"""Testing the malware_cache module

To run tests just enter the apk-total file in terminal and run the command:
pytest -v
"""

from malware_cache import FileEntry, FileEntryCache
from unittest.mock import patch
import datetime

MOCK_FILE_CREATION_TIME = datetime.datetime(1999, 12, 31)


# ============================================= testing FileEntry =============================================


def test_FileEntry_init_calls_datetime_correctly():
    """test if FileEntry calls datetime.datetime.now() exactly once when a FileEntry gets created"""
    with patch("datetime.datetime") as mock_datetime:
        mock_datetime.now.return_value = MOCK_FILE_CREATION_TIME

        mock_entry = FileEntry(filename="foo",
                               path="imaginary",
                               md5="123",
                               sha1="234",
                               sha256="345",
                               contains_malware=True,
                               contains_trackers=False,
                               contains_adware=False)

        # check if FileEntry.first_seen was set to correct datetime
        assert mock_entry.first_seen == MOCK_FILE_CREATION_TIME

        # sanity-check: datetime.datetime.now() should have been called exactly one time, with no arguments
        mock_datetime.now.assert_called_once_with()


def dont_test_FileEntry_analyzed_time():  # TODO: find out which function sets analyzed_at (FileEntry attribute) time and test it
    pass


def test_FileEntry_hash_function():
    """tests looking up the hash with __hash__ returns stored sha256 value"""
    test_entry = FileEntry(filename="foo",
                           path="imaginary",
                           md5="123",
                           sha1="234",
                           sha256="012345789ABCDEFGH",
                           contains_malware=True,
                           contains_trackers=False,
                           contains_adware=False)

    assert test_entry.__hash__() == "012345789ABCDEFGH"  # this works
    assert hash(test_entry) == "012345789ABCDEFGH"  # this fails: seems like the builtin __hash__ should always return an int TODO: fix


def test_two_FileEntries_with_same_sha256_are_equal():
    """compares 2 files with all attributes different except for having the same sha256 value"""
    test_entry1 = FileEntry(filename="foo",
                            path="imaginary",
                            md5="1",
                            sha1="2",
                            sha256="ABC123DEF456",
                            contains_malware=True,
                            contains_trackers=False,
                            contains_adware=False)

    test_entry2 = FileEntry(filename="bar",
                            path="real",
                            md5="3",
                            sha1="4",
                            sha256="ABC123DEF456",
                            contains_malware=False,
                            contains_trackers=True,
                            contains_adware=True)

    assert test_entry1 == test_entry2


def test_two_FileEntries_with_different_sha256_are_not_equal():
    """compares 2 files with all attributes the same except for having the different sha256 value"""
    test_entry1 = FileEntry(filename="foo",
                            path="imaginary",
                            md5="1",
                            sha1="2",
                            sha256="ABC123DEF456",
                            contains_malware=True,
                            contains_trackers=False,
                            contains_adware=False)

    test_entry2 = FileEntry(filename="foo",
                            path="imaginary",
                            md5="1",
                            sha1="2",
                            sha256="NOT THE SAME AS OTHER FILE",
                            contains_malware=True,
                            contains_trackers=False,
                            contains_adware=False)

    assert test_entry1 != test_entry2


def test_FileEntry_dunder_str():
    """test if __str__ returns correct output with mocked datetime"""
    with patch("datetime.datetime") as mock_datetime:
        mock_datetime.now.return_value = MOCK_FILE_CREATION_TIME
        test_entry = FileEntry(filename="foo",
                               path="test",
                               md5="1",
                               sha1="2",
                               sha256="ABC123",
                               contains_malware=True,
                               contains_trackers=False,
                               contains_adware=False)

    # test for correct output
    assert str(test_entry) == '{"filename": "foo",' \
                              ' "path": "test",' \
                              ' "md5": "1",' \
                              ' "sha1": "2",' \
                              ' "sha256": "ABC123",' \
                              ' "contains_malware": true,' \
                              ' "contains_trackers": false,' \
                              ' "contains_adware": false,' \
                              f' "first_seen": "{MOCK_FILE_CREATION_TIME}",' \
                              ' "analyzed_at": "None"}'

    # sanity-check: make sure datetime.datetime.now was called exactly once with no arguments
    mock_datetime.now.assert_called_once_with()


def test_FileEntry_dunder_repr():
    """test if __repr__ returns correct output with mocked datetime"""
    with patch("datetime.datetime") as mock_datetime:
        mock_datetime.now.return_value = MOCK_FILE_CREATION_TIME
        test_entry = FileEntry(filename="foo",
                               path="test",
                               md5="1",
                               sha1="2",
                               sha256="ABC123",
                               contains_malware=True,
                               contains_trackers=False,
                               contains_adware=False)

    # test for correct output
    assert repr(test_entry) == '{"filename": "foo",' \
                               ' "path": "test",' \
                               ' "md5": "1",' \
                               ' "sha1": "2",' \
                               ' "sha256": "ABC123",' \
                               ' "contains_malware": true,' \
                               ' "contains_trackers": false,' \
                               ' "contains_adware": false,' \
                               f' "first_seen": "{MOCK_FILE_CREATION_TIME}",' \
                               ' "analyzed_at": "None"}'

    # sanity-check: make sure datetime.datetime.now was called exactly once with no arguments
    mock_datetime.now.assert_called_once_with()


# ============================================= testing FileEntryCache =============================================


def test_file_in_FileEntryCache():
    test_entry = FileEntry(filename="foo",
                           path="imaginary",
                           md5="123",
                           sha1="234",
                           sha256="345",
                           contains_malware=True,
                           contains_trackers=False,
                           contains_adware=False)

    cache = FileEntryCache()
    cache.insert(test_entry)

    assert test_entry in cache
    assert cache.was_analyzed(test_entry)


def test_file_not_in_FileEntryCache():
    test_entry = FileEntry(filename="this file should not be in cache",
                           path="since it is never inserted",
                           md5="12345",
                           sha1="23456",
                           sha256="34567",
                           contains_malware=False,
                           contains_trackers=True,
                           contains_adware=True)

    cache = FileEntryCache()

    assert test_entry not in cache
    assert not cache.was_analyzed(test_entry)


def test_FileEntryCache_lookup_count_is_zero():
    test_entry = FileEntry(filename="this file should not be in cache",
                           path="since it is never inserted",
                           md5="12345",
                           sha1="23456",
                           sha256="34567",
                           contains_malware=False,
                           contains_trackers=True,
                           contains_adware=True)

    cache = FileEntryCache()

    assert cache._lookup_count(test_entry) == 0


def test_FileEntryCache_lookup_count_is_one():
    test_entry = FileEntry(filename="foo",
                           path="imaginary",
                           md5="123",
                           sha1="234",
                           sha256="345",
                           contains_malware=True,
                           contains_trackers=False,
                           contains_adware=False)

    cache = FileEntryCache()
    cache.insert(test_entry)

    assert cache._lookup_count(test_entry) == 1


def test_FileCacheEntry_duplicate_input_unsuccesfull_insert():
    test_entry = FileEntry(filename="foo",
                           path="imaginary",
                           md5="123",
                           sha1="234",
                           sha256="345",
                           contains_malware=True,
                           contains_trackers=False,
                           contains_adware=False)

    cache = FileEntryCache()
    cache.insert(test_entry)  # first insert to make sure file is already in database

    assert cache.insert(test_entry) is False  # second insert should return False due to duplicate key value


def test_FileCacheEntry_invalid_input_results_in_unsuccesfull_insert():  # TODO: should this raise an error?
    not_a_file = "this is not a valid FileEntry"
    cache = FileEntryCache()

    assert cache.insert(not_a_file) is False


def dont_test_FileCacheEntry_valid_input_succesfull_insert():
    pass  # TODO: figure out a way to setup/teardown database to implement this test


def dont_test_FileCacheEntry_items_lookup():
    pass  # TODO: figure out a way to setup/teardown database to implement this test


def dont_test_FileCacheEntry_dunder_len():
    pass  # TODO: figure out a way to setup/teardown database to implement this test


def dont_test_FileCacheEntry_get_cached_results():
    pass  # TODO: figure out a way to setup/teardown database to implement this test
    # TODO: once that's complete, also write tests for the 3 contains_antifeatures methods (contains_trackers, contains_malware, contains_adware)
